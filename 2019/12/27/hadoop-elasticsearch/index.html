<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/MyBlog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/MyBlog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/MyBlog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/MyBlog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/MyBlog/css/main.css">


<link rel="stylesheet" href="/MyBlog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/MyBlog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"winyter.github.io","root":"/MyBlog/","scheme":"Gemini","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"path":"search.json"};
  </script>

  <meta name="description" content="ES简介ES数据模型">
<meta property="og:type" content="article">
<meta property="og:title" content="Hadoop快速入门系列——篇二：ElasticSearch">
<meta property="og:url" content="https:&#x2F;&#x2F;winyter.github.io&#x2F;MyBlog&#x2F;2019&#x2F;12&#x2F;27&#x2F;hadoop-elasticsearch&#x2F;index.html">
<meta property="og:site_name" content="花不醉的小花园">
<meta property="og:description" content="ES简介ES数据模型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http:&#x2F;&#x2F;cdn.winyter.cn&#x2F;hadoop-elasticsearch_image1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;cdn.winyter.cn&#x2F;hadoop-elasticsearch_image2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;cdn.winyter.cn&#x2F;hadoop-elasticsearch_image3.png">
<meta property="article:published_time" content="2019-12-26T16:35:11.000Z">
<meta property="article:modified_time" content="2020-07-25T11:16:10.461Z">
<meta property="article:author" content="winyter">
<meta property="article:tag" content="Hadoop">
<meta property="article:tag" content="ElasticSearch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;cdn.winyter.cn&#x2F;hadoop-elasticsearch_image1.png">

<link rel="canonical" href="https://winyter.github.io/MyBlog/2019/12/27/hadoop-elasticsearch/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Hadoop快速入门系列——篇二：ElasticSearch | 花不醉的小花园</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/MyBlog/atom.xml" title="花不醉的小花园" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/MyBlog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">花不醉的小花园</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">携一生所爱，看遍世间美好</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/MyBlog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/MyBlog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/MyBlog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/MyBlog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ES简介"><span class="nav-text">ES简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES数据模型"><span class="nav-text">ES数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES架构"><span class="nav-text">ES架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES环境加载"><span class="nav-text">ES环境加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES命令的使用"><span class="nav-text">ES命令的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON基本语法原则"><span class="nav-text">JSON基本语法原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础curl命令"><span class="nav-text">基础curl命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取集群基础信息"><span class="nav-text">获取集群基础信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的数据增删改命令"><span class="nav-text">基本的数据增删改命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES搜索-查询命令，以及高级的query、filter、聚合搜索操作"><span class="nav-text">ES搜索&#x2F;查询命令，以及高级的query、filter、聚合搜索操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础的查询命令"><span class="nav-text">基础的查询命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询DSL-—-query"><span class="nav-text">查询DSL — query</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过滤DSL-—-filter"><span class="nav-text">过滤DSL — filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#query与filter的区别"><span class="nav-text">query与filter的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚合查询"><span class="nav-text">聚合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Metric聚合"><span class="nav-text">Metric聚合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bucket聚合"><span class="nav-text">Bucket聚合</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="winyter"
      src="/MyBlog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">winyter</p>
  <div class="site-description" itemprop="description">IT,Photograph,Travel,Love</div>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/winyter" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;winyter" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mrwinterwei@outlook.com" title="E-Mail → mailto:mrwinterwei@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/winyter" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://winyter.github.io/MyBlog/2019/12/27/hadoop-elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/MyBlog/images/avatar.jpg">
      <meta itemprop="name" content="winyter">
      <meta itemprop="description" content="IT,Photograph,Travel,Love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花不醉的小花园">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hadoop快速入门系列——篇二：ElasticSearch
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-27 00:35:11" itemprop="dateCreated datePublished" datetime="2019-12-27T00:35:11+08:00">2019-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-25 19:16:10" itemprop="dateModified" datetime="2020-07-25T19:16:10+08:00">2020-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/MyBlog/categories/CS-Concept/" itemprop="url" rel="index"><span itemprop="name">CS Concept</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/MyBlog/categories/CS-Concept/Bigdata/" itemprop="url" rel="index"><span itemprop="name">Bigdata</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h2><h3 id="ES数据模型"><a href="#ES数据模型" class="headerlink" title="ES数据模型"></a>ES数据模型</h3><a id="more"></a>

<p><strong>Index</strong>：即索引，是Elasticsearch中一个逻辑命名空间，指向一个或多个分片，内部Apache Lucene实现索引中数据的读写。索引与关系数据库实例Database相当。一个Elasticsearch实例可以包含多个索引。<br><strong>Type</strong>：文档类型，文档类型使得同一个索引中在存储结构不同的文档时，只需要依据文档类型就可以找到对应的参数映射信息，方便文档的存储。相当于数据库中的Table。一个索引对应一个文档类型。<br><strong>Document</strong>：文档，是可以被索引的基本单位，特指最顶层结构或根对象序列化成的JSON数据。相当于数据库中的Row。一个类型包含多个文档。<br><strong>Field</strong>：字段，组成文档的最小单位。相当于数据库中的Column。每个文档包含多个字段。<br><strong>Mapping</strong>：相当于数据库中的schema，用来约束字段的类型，不过 Elasticsearch 的 mapping 可以自动根据数据创建</p>
<p><img src="http://cdn.winyter.cn/hadoop-elasticsearch_image1.png" alt="图1 ES数据模型模拟"></p>
<h3 id="ES架构"><a href="#ES架构" class="headerlink" title="ES架构"></a>ES架构</h3><p><strong>EsNode</strong>：Elasticsearch节点，一个节点就是一个Elasticsearch实例。<br><strong>EsMaster</strong>：主节点，可以临时管理集群级别的一些变更，例如新建或删除索引、增加或移除节点等。主节点不参与文档级别的变更或搜索，在流量增长时，该主节点不会成为集群的瓶颈。<br><strong>primary shard</strong>：主分片，索引中的每个文档属于一个单独的主分片，主分片的数量决定了索引最多能存储多少数据。<br><strong>replica shard</strong>：即复制分片，它是主分片的一个副本，可以防止硬件故障导致的数据丢失，同时可以提供读请求，比如搜索或者从别的shard取回文档。<br><strong>recovery</strong>：代表数据恢复或叫数据重新分布，Elasticsearch在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。<br><strong>gateway</strong>：代表Elasticsearch索引快照的存储方式，默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个Elasticsearch集群关闭再重新启动时就会从gateway中读取索引备份数据。支持多种类型的gateway，有本地文件系统（默认），分布式文件系统，Hadoop的HDFS和amazon的s3云存储服务。<br><strong>transport</strong>：代表Elasticsearch内部节点或集群与客户端的交互方式，默认内部是使用tcp协议进行交互，同时它支持http协议（json格式）、thrift、servlet、memcached、zeroMQ等的传输协议（通过插件方式集成）。<br><strong>ZooKeeper</strong>：它在Elasticsearch是必须的，提供安全认证信息的存储等功能。<br><strong>shard（分片）</strong>：是工作单元(worker unit) 底层的一员，用来分配集群中的数据，它只负责保存索引中所有数据的一小片。</p>
<ul>
<li>分片是一个独立的Lucene实例，并且它自身也是一个完整的搜索引擎。</li>
<li>文档存储并且被索引在分片中，但是我们的程序并不会直接与它们通信。取而代之，它们直接与索引进行通信的</li>
<li>把分片想象成一个数据的容器。数据被存储在分片中，然后分片又被分配在集群的节点上。当你的集群扩展或者缩小时，elasticsearch 会自动的在节点之间迁移分配分片，以便集群保持均衡</li>
<li>分片分为 主分片(primary shard) 以及 从分片(replica shard) 两种。在你的索引中，每一个文档都属于一个主分片</li>
<li>从分片只是主分片的一个副本，它用于提供数据的冗余副本，在硬件故障时提供数据保护，同时服务于搜索和检索这种只读请求</li>
<li>索引中的主分片的数量在索引创建后就固定下来了，但是从分片的数量可以随时改变。</li>
<li>一个索引默认设置了5个主分片，每个主分片有一个从分片对应</li>
</ul>
<h2 id="ES环境加载"><a href="#ES环境加载" class="headerlink" title="ES环境加载"></a>ES环境加载</h2><p>1、登录安装了ES客户端的节点<br>2、登录相应用户<br>3、加载环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg.source &#x2F;home&#x2F;websrv&#x2F;client&#x2F;hadoopClient&#x2F;bigdata_env</span><br></pre></td></tr></table></figure>
<p>4、执行安全认证（如果使用的是非安全认证的集群，本步骤可以跳过）<br>进入 认证文件所在目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg.&#x2F;home&#x2F;websrv&#x2F;keytab&#x2F;hbase</span><br></pre></td></tr></table></figure>
<p>查看认证用户名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">klist -kt user.keytab</span><br></pre></td></tr></table></figure>
<p>执行认证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kinit -kt user.keytab &lt;组件业务用户名&gt;  --&lt;组件业务用户名&gt;即上一步看到的</span><br></pre></td></tr></table></figure>
<p>认证用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. kinit -kt user.keytab tjhj_zxsk_jj@HBASE.COM</span><br></pre></td></tr></table></figure>
<p>然后再登录hbase shell即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拓展：klist  ——&gt;  查看认证时间</span><br></pre></td></tr></table></figure>
<p>5、使用curl命令进行操作<br>命令使用方法参见下一节的介绍</p>
<h2 id="ES命令的使用"><a href="#ES命令的使用" class="headerlink" title="ES命令的使用"></a>ES命令的使用</h2><p>ES 的命令主要是curl命令。ElasticSearch的命令调用是基于http的，提供了丰富的RESTFul API，从功能上来分可以分为3类：<br>    (1)    获取集群基础信息；<br>    (2)    基本的数据增删改命令；<br>(3)    ES搜索/查询命令，以及高级的query、filter、聚合搜索操作；<br>其中，对于ES数据的搜索时本节讲述的重点，也是日常维护工作中使用最频繁的ES命令。ES的搜索命令从命令格式上来划分有两种方式：<br>一是通过RESTfulrequest API传递查询参数，也称“query-string”；<br>另一个是通过发送REST request body，也称作JSON格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># query-string格式：</span><br><span class="line">curl -XGET ‘192.168.226.133:9200&#x2F;my_index&#x2F;my_type&#x2F;_search?pretty’</span><br><span class="line"># JSON格式：</span><br><span class="line">curl - XGET &#39;localhost:9200&#x2F;my_index&#x2F;my_type&#x2F;_search?pretty&#39; -d&#39;</span><br><span class="line">       &#123;</span><br><span class="line">         &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125; &#125;</span><br><span class="line">       &#125;&#39;</span><br></pre></td></tr></table></figure>
<p>由于JSON格式更加友好美观，所以目前大部分对ES的查询命令都使用该格式表达，本节也会以这种格式介绍为主，所以在介绍详细命令的使用之前，会先介绍基本的JSON语法原则和基本CURL命令格式。</p>
<h3 id="JSON基本语法原则"><a href="#JSON基本语法原则" class="headerlink" title="JSON基本语法原则"></a>JSON基本语法原则</h3><ul>
<li>数据在键/值对中：<br>JSON 数据的书写格式是：键/值对。键/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;firstName&quot; : &quot;John&quot;</span><br></pre></td></tr></table></figure></li>
<li>数据由逗号分隔</li>
<li>花括号保存对象：<br>JSON 对象在花括号中书写，对象可以包含多个键/值对，多个键值对用逗号分隔：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;</span><br></pre></td></tr></table></figure></li>
<li>方括号保存数组：<br>JSON 数组在方括号中书写，数组可包含多个对象：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;employees&quot;: [</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="基础curl命令"><a href="#基础curl命令" class="headerlink" title="基础curl命令"></a>基础curl命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl [options…] &lt;url&gt;</span><br><span class="line"></span><br><span class="line">	常用操作符：</span><br><span class="line">	-XGET	--指定本次命令为查询请求</span><br><span class="line">	-XPUT	--指定本次命令为新增修改请求</span><br><span class="line">	-XDELETE	--指定本次命令为删除请求</span><br><span class="line">	### 上面三个操作符必须选择一个，具体如何选择根据实际的增删改查操作需求</span><br><span class="line">	--negotiate	--使用HTTP身份认证，如果使用HTTP协议方式连接，该操作符必选</span><br><span class="line">	-k	--允许不使用证书到SSL站点，天津现场建议选择，其他现场按需选择</span><br><span class="line">	-v	--显示版本信息</span><br><span class="line">	-u	--设置服务器的用户名和密码</span><br><span class="line">	-H	--自定义头信息传递给服务，默认即可</span><br><span class="line">	-d	--HTTP POST方式传送数据，此处指文档内容</span><br><span class="line">以上操作符为常用的curl命令操作符，如果有其它操作符需求，可以在命令行键入：curl –help</span><br></pre></td></tr></table></figure>

<h3 id="获取集群基础信息"><a href="#获取集群基础信息" class="headerlink" title="获取集群基础信息"></a>获取集群基础信息</h3><p>获取集群健康状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -k -v -u : https:&#x2F;&#x2F;ip:httpport&#x2F;_cluster&#x2F;health?pretty</span><br></pre></td></tr></table></figure>
<p>注意：ip:httpport需要填写ES集群中一个节点的IP地址，不需要填写所有的节点IP，ES集群会自行查询整个集群，httpport是该节点上已安装的任意ES实例的HTTP端口，需要查询确定<br>查询所有索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;ip:httpport&#x2F;_cat&#x2F;indices?v&#39;</span><br></pre></td></tr></table></figure>
<p>查看指定索引的mapping</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;ip:httpport&#x2F;索引名&#x2F;_mapping?pretty&#39;</span><br></pre></td></tr></table></figure>
<p>查看指定索引的setting</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;ip:httpport&#x2F;索引名&#x2F;_settings?pretty&#39; --setting	即该索引的结构</span><br></pre></td></tr></table></figure>
<p>检查文档是否存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i -XHEAD --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;ip:httpport&#x2F;索引名&#x2F;文档类型&#x2F;索引ID&#39;</span><br></pre></td></tr></table></figure>

<h3 id="基本的数据增删改命令"><a href="#基本的数据增删改命令" class="headerlink" title="基本的数据增删改命令"></a>基本的数据增删改命令</h3><p>新建索引，并设置副本数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPUT --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;ip:httpport&#x2F;索引名?pretty&#39; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39; &#123;&quot;settings&quot; : &#123;&quot;number_of_shards&quot; : 分片数量,&quot;number_of_replicas&quot; : 副本数量&#125; &#125;&#39;</span><br><span class="line"></span><br><span class="line">例如：curl -XPUT --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;1.1.1.1:24148&#x2F;website?pretty&#39; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39; &#123;&quot;settings&quot; : &#123;&quot;number_of_shards&quot; : 3,&quot;number_of_replicas&quot; : 1&#125; &#125;&#39;</span><br></pre></td></tr></table></figure>
<p>写入数据，更新索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XPOST --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;ip:httpport&#x2F;索引名&#x2F;文档类型&#x2F;索引ID?pretty&#39; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39; &#123; &#125;&#39;</span><br><span class="line"></span><br><span class="line">例如：curl -XPOST --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;1.1.1.1:24148&#x2F;website&#x2F;blog&#x2F;123?pretty&#39; -H &#39;Content-Type: application&#x2F;json&#39; -d&#39; &#123;&quot;title&quot;: &quot;My first blog entry&quot;, &quot;text&quot;: &quot;Just trying this out...&quot;,&quot;date&quot;: &quot;2014&#x2F;01&#x2F;01&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>
<p>删除文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XDELETE --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;ip:httpport&#x2F;索引名&#x2F;索引类型&#x2F;索引ID?pretty&#39;</span><br><span class="line"></span><br><span class="line">例如：curl -XDELETE --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;1.1.1.1:24148&#x2F;website&#x2F;blog&#x2F;123?pretty&#39;</span><br></pre></td></tr></table></figure>

<h3 id="ES搜索-查询命令，以及高级的query、filter、聚合搜索操作"><a href="#ES搜索-查询命令，以及高级的query、filter、聚合搜索操作" class="headerlink" title="ES搜索/查询命令，以及高级的query、filter、聚合搜索操作"></a>ES搜索/查询命令，以及高级的query、filter、聚合搜索操作</h3><h4 id="基础的查询命令"><a href="#基础的查询命令" class="headerlink" title="基础的查询命令"></a>基础的查询命令</h4><p>查询所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -H &#39;Content-Type: application&#x2F;json&#39; -k -v -u : &#39;https:&#x2F;&#x2F;17.22.142.3:24148&#x2F;索引名&#x2F;文档类型&#x2F;_search?pretty&#39;  -d&#39; &#123;</span><br><span class="line">&quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_all&quot; : &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#39;</span><br></pre></td></tr></table></figure>
<p>根据rowkey查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -H &#39;Content-Type: application&#x2F;json&#39; -k -v -u : &#39;https:&#x2F;&#x2F;17.22.142.3:24148&#x2F;索引名&#x2F;文档类型&#x2F;_search?pretty&#39;  -d&#39; &#123;</span><br><span class="line">&quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;&quot;rowkey&quot;:&quot;KX6ncmYBWgNWo4LeB0VD&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#39;</span><br><span class="line">索引名可以用2019*形式，表示查询范围是以2019开头的索引</span><br></pre></td></tr></table></figure>
<p>返回文档的一部分数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -k -v -u : &#39;https:&#x2F;&#x2F;ip:httpport&#x2F;索引名&#x2F;文档类型&#x2F;索引ID?_source&#x3D;文档属性名,文档属性名&amp;pretty&#39;</span><br></pre></td></tr></table></figure>
<p>此外，在搜索时url中可以指定索引名和类型名以减少搜索的范围：</p>
<ul>
<li>/_search：搜索所有索引的所有类型；</li>
<li>/my_index/_search：搜索my_index索引的所有类型；</li>
<li>/students, my_index /_search：搜索students和my_index索引的所有类型；</li>
<li>/ my_*/_search：搜索名称以my_开头的所有索引的所有类型；</li>
<li>/ my_index/customer/_search：搜索my_index索引的customer类型；</li>
<li>/_all/customer/_search：搜索所有索引的customer类型</li>
</ul>
<p>PS：一旦你取回了你的搜索结果，Elasticsearch就完成了使命，它不会维护任何服务器端的资源或者在你的结果中打开游标，这也是RESTFul风格的一个特性，也注定了ES每次返回值默认是有限制的。</p>
<p>由于REST request body的JSON格式从可读性和灵活性来说都给开发者带来太多的美感，所以实际应用中重点使用JSON格式，这种查询语句又被称为DSL。而DSL又因原理不同被划分为查询DSL(query DSL)和过滤DSL(filter DSL)。</p>
<p>DSL格式如果再使用linux的curl命令来书写那真是太累了，建议使用ELK组合中的Kibana来帮助查询ES。<br>下载地址：<a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/downloads/kibana</a></p>
<p>按照官网的教程：<br>1下载解压<br>2配置config/kibana.yml<br>3执行bin/kibana<br>4浏览器访问<a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a></p>
<p><img src="http://cdn.winyter.cn/hadoop-elasticsearch_image2.png" alt="图2 Kibana界面展示"></p>
<p>从上面的很多命令可以看到，基础的curl命令实际上是使用的query-string格式，但是，该格式仅在简单的命令中有着优势，在面对较为复杂的查询需求，query-string格式就显得心有余而力不足，因此，随着查询需求的越来越高级，curl命令主体的格式也慢慢转变成了JSON格式，这个现象在本段上面的两条查询语句中得到了证实，而下面将会深入讲解curl命令的几个高级搜索特性，这些搜索特性，全都基于JSON格式。</p>
<h4 id="查询DSL-—-query"><a href="#查询DSL-—-query" class="headerlink" title="查询DSL — query"></a>查询DSL — query</h4><p>在查询上下文中，查询会回答这个问题——“这个文档匹不匹配这个查询，它的相关度高么？”<br>虽然与Oracle、MySQL同有数据存储的功能，但ES本质上是一个搜索引擎，搜索引擎意味着它需要去判断查询请求与查询内容之间的“相关度”的问题，ES为了实现“相关度”，引入了“评分”（score）这个概念，而query查询就是实现“评分”这个能力的关键<br>下面会使用一个例子体现query查询的特性，顺带，也会展示ES查询的请求与响应的细节：</p>
<p>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -H &#39;Content-Type: application&#x2F;json&#39; -k -v -u : &#39;https:&#x2F;&#x2F;17.22.142.3:24148&#x2F;sample&#x2F;type&#x2F;_search?pretty&#39;  -d&#39; &#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;state&quot;: &quot;UT&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: 10, </span><br><span class="line">  &quot;size&quot;: 2,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;_source&quot;: [&quot;account_number&quot;,&quot;address&quot;,&quot;state&quot;,&quot;age&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--query		与之相对的是filter，两者的区别后面会详细介绍</span><br><span class="line">--match		里面是查询条件，与query匹配使用</span><br><span class="line">--size		代表结果取数返回记录数，像limit或rownum的作用。默认为10</span><br><span class="line">--from		是标识从第几条记录开始取值。默认为0</span><br><span class="line">--sort		标识按什么排序</span><br><span class="line">--_source	标识返回集中的字段名，像select后的属性，默认是select *</span><br></pre></td></tr></table></figure>
<p>响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 30,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;skipped&quot;: 0,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 20,</span><br><span class="line">    &quot;max_score&quot;: null,</span><br><span class="line">    &quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;customer&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;465&quot;,</span><br><span class="line">        &quot;_score&quot;: null,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;account_number&quot;: 465,</span><br><span class="line">          &quot;address&quot;: &quot;916 Evergreen Avenue&quot;,</span><br><span class="line">          &quot;state&quot;: &quot;UT&quot;,</span><br><span class="line">          &quot;age&quot;: 29</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sort&quot;: [</span><br><span class="line">          29</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;my_index&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;customer&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;758&quot;,</span><br><span class="line">        &quot;_score&quot;: null,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;account_number&quot;: 758,</span><br><span class="line">          &quot;address&quot;: &quot;149 Surf Avenue&quot;,</span><br><span class="line">          &quot;state&quot;: &quot;UT&quot;,</span><br><span class="line">          &quot;age&quot;: 28</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sort&quot;: [</span><br><span class="line">          28</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">简单说返回内容包括2部分。</span><br><span class="line">一部分是本次搜索的基本信息：</span><br><span class="line">--took		消耗的时间，单位是ms</span><br><span class="line">--shards		分片被检索的信息</span><br><span class="line">--hits.total		满足搜索条件的记录个数；</span><br><span class="line">--hits.hits		返回结果集</span><br><span class="line">另一部分是搜索结果集：</span><br><span class="line">--index		结果所在索引</span><br><span class="line">--type		结果所在类型</span><br><span class="line">--id			结果的ID</span><br><span class="line">--score		结果的评分（需要了解Lucene中df&#x2F;tf的概念Lucene原理分析）</span><br><span class="line">--source		如前面所说select *里的内容</span><br></pre></td></tr></table></figure>

<h4 id="过滤DSL-—-filter"><a href="#过滤DSL-—-filter" class="headerlink" title="过滤DSL — filter"></a>过滤DSL — filter</h4><p>在过滤器上下文中，查询会回答这个问题——“这个文档匹不匹配？”</p>
<p>答案很简单，是或者不是。它不会去计算任何分值，也不会关心返回的排序问题，因此效率会高一点。</p>
<p>过滤上下文 是在使用filter参数时候的执行环境，比如在bool查询中使用Must_not或者filter</p>
<p>另外，经常使用过滤器，ES会自动的缓存过滤器的内容，这对于查询来说，会提高很多性能。</p>
<p>为了便于理解，下面列举一些过滤的情况：<br>创建日期是否在2013-2014年间？<br>status字段是否为published？<br>lat_lon字段是否在某个坐标的10公里范围内？</p>
<p>从上面的例子中可以看到，过滤器上下文中，查询操作仅判断是否满足查询条件。</p>
<p>最后，使用一个例子，来演示一下filter的使用：<br>搜索年龄在20-25之间，余额在20000-35000之间，地址包含Street，或者邮箱包含schultzmoreno的这样的记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -H &#39;Content-Type: application&#x2F;json&#39; -k -v -u : &#39;https:&#x2F;&#x2F;17.22.142.3:24148&#x2F;sample&#x2F;type&#x2F;_search?pretty&#39;  -d&#39; &#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;:&#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;&quot;match&quot;: &#123;</span><br><span class="line">          &quot;address&quot;: &quot;Street&quot;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">        &#123;&quot;match&quot;: &#123;</span><br><span class="line">          &quot;email&quot;: &quot;schultzmoreno&quot;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">        &quot;age&quot;: &#123;</span><br><span class="line">          &quot;gte&quot;: 20,</span><br><span class="line">          &quot;lte&quot;: 25</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">        &quot;balance&quot;: &#123;</span><br><span class="line">          &quot;gte&quot;: 20000,</span><br><span class="line">          &quot;lte&quot;: 35000</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: 0, </span><br><span class="line">  &quot;size&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="query与filter的区别"><a href="#query与filter的区别" class="headerlink" title="query与filter的区别"></a>query与filter的区别</h4><p><img src="http://cdn.winyter.cn/hadoop-elasticsearch_image3.png" alt="图3 query与filter的区别"></p>
<p>query与filter虽然有相对关系，但在实际使用中，并不存在两者不能共用的问题，正如上面的那个查询语句示例，filter嵌套在query里面，在实际使用中，两者的使用仅看查询的需求，如果需要query查询那样的全文搜索、评分功能，那么就使用query，如果需要filter过滤那样的精准判断，那么就使用filter，下面同样以一个例子，展示query与filter的混合使用，以及如何去根据实际需求，组织查询语句：</p>
<p>假设现在我们需要查询一个邮箱数据库，查询收件箱中，邮件内容包含business opportunity 的邮件：</p>
<p>首先，获取邮件内容中有“business opportunity”的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;match&quot;: &#123; </span><br><span class="line">        &quot;email&quot;: &quot;business opportunity&quot; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，限定只在收件箱中查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;term&quot;: &#123; </span><br><span class="line">        &quot;folder&quot;: &quot;inbox&quot; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，对这两条语句进行拼合，match语句很明显是一个query查询，而team语句则可以看出是一个filter过滤，由于search API中只能包含 query 语句，所以我们需要用 filtered 来同时包含 &quot;query&quot; 和 &quot;filter&quot; 子句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;filtered&quot;: &#123; </span><br><span class="line">        &quot;query&quot;:  &#123; &quot;match&quot;: &#123; &quot;email&quot;: &quot;business opportunity&quot; &#125;&#125;, </span><br><span class="line">        &quot;filter&quot;: &#123; &quot;term&quot;:  &#123; &quot;folder&quot;: &quot;inbox&quot; &#125;&#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们在最外层加上query的上下文关系以及curl命令主体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -H &#39;Content-Type: application&#x2F;json&#39; -k -v -u : &#39;https:&#x2F;&#x2F;17.22.142.3:24148&#x2F;sample&#x2F;type&#x2F;_search?pretty&#39;  -d&#39;</span><br><span class="line">&#123; </span><br><span class="line">    &quot;query&quot;: &#123; </span><br><span class="line">        &quot;filtered&quot;: &#123; </span><br><span class="line">            &quot;query&quot;:  &#123; &quot;match&quot;: &#123; &quot;email&quot;: &quot;business opportunity&quot; &#125;&#125;, </span><br><span class="line">            &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;folder&quot;: &quot;inbox&quot; &#125;&#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，一个简单的复合查询命令就已经完成，只需要执行，便能得到想要的结果。</p>
<h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><p>Elasticsearch具有称为聚合的功能，允许您对数据生成复杂的分组和分析，像是Oracle中的group by、avg等，而且更强大。</p>
<h5 id="Metric聚合"><a href="#Metric聚合" class="headerlink" title="Metric聚合"></a>Metric聚合</h5><p>先看运算，跟Oracle类似有sum、max、min、avg、count等，在ES中可以单独算某一种运算外，还提供了一个stats参数，一次请求把以上所有结果都返回出来。</p>
<p>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -H &#39;Content-Type: application&#x2F;json&#39; -k -v -u : &#39;https:&#x2F;&#x2F;17.22.142.3:24148&#x2F;sample&#x2F;type&#x2F;_search?pretty&#39;  -d&#39;&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_name&quot;: &#123;</span><br><span class="line">      &quot;stats&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--Aggs		代表是启用聚合功能了，固定套路。</span><br><span class="line">--My_name	给聚合返回的结果集起一个别名，单独看不出意义，嵌套聚合的时候体现价值。</span><br><span class="line">--Stats		聚合的操作命令，这里是统计的命令，可以换成sum、max、min、avg、term等各种各样ES内置的命令。</span><br><span class="line">--Field		指定被聚合的属性名。</span><br><span class="line">--Size		指定结果集中要返回多少条被本次聚合命中的document，如果只关心聚合结果不关心命中的记录，size请指定为0。</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 24,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;skipped&quot;: 0,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 1000,</span><br><span class="line">    &quot;max_score&quot;: 0,</span><br><span class="line">    &quot;hits&quot;: []</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggregations&quot;: &#123;</span><br><span class="line">    &quot;my_name&quot;: &#123;</span><br><span class="line">      &quot;count&quot;: 1000,</span><br><span class="line">      &quot;min&quot;: 20,</span><br><span class="line">      &quot;max&quot;: 40,</span><br><span class="line">      &quot;avg&quot;: 30.171,</span><br><span class="line">      &quot;sum&quot;: 30171</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Bucket聚合"><a href="#Bucket聚合" class="headerlink" title="Bucket聚合"></a>Bucket聚合</h5><p>桶子的意思，根据条件把数据按照木桶封装好，有点Oracle中group by的意思。</p>
<p>请求：按照年龄把文档按桶子分分类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -H &#39;Content-Type: application&#x2F;json&#39; -k -v -u : &#39;https:&#x2F;&#x2F;17.22.142.3:24148&#x2F;sample&#x2F;type&#x2F;_search?pretty&#39;  -d&#39;&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_name&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 92,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;skipped&quot;: 0,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 1000,</span><br><span class="line">    &quot;max_score&quot;: 0,</span><br><span class="line">    &quot;hits&quot;: []</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggregations&quot;: &#123;</span><br><span class="line">    &quot;my_name&quot;: &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot;: 0,</span><br><span class="line">      &quot;sum_other_doc_count&quot;: 463,</span><br><span class="line">      &quot;buckets&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 31,</span><br><span class="line">          &quot;doc_count&quot;: 61</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 39,</span><br><span class="line">          &quot;doc_count&quot;: 60</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 26,</span><br><span class="line">          &quot;doc_count&quot;: 59</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 32,</span><br><span class="line">          &quot;doc_count&quot;: 52</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 35,</span><br><span class="line">          &quot;doc_count&quot;: 52</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 36,</span><br><span class="line">          &quot;doc_count&quot;: 52</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 22,</span><br><span class="line">          &quot;doc_count&quot;: 51</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 28,</span><br><span class="line">          &quot;doc_count&quot;: 51</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 33,</span><br><span class="line">          &quot;doc_count&quot;: 50</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: 34,</span><br><span class="line">          &quot;doc_count&quot;: 49</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个年龄都有一桶记录在里面，默认是按照桶里数据多少来排序的，可以在field后添加 <code>&quot;order&quot; : { &quot;_term&quot; : &quot;asc&quot;}</code>指定按照内容来排序。</p>
<p>还可以与前面的运算嵌套使用，我想算一下每个年龄存款的平均水平：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -XGET --negotiate -H &#39;Content-Type: application&#x2F;json&#39; -k -v -u : &#39;https:&#x2F;&#x2F;17.22.142.3:24148&#x2F;sample&#x2F;type&#x2F;_search?pretty&#39;  -d&#39;&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_name&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;,</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">          &quot;avg_balance&quot;: &quot;desc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;avg_balance&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，ES命令的介绍基本结束，本章讲述的命令并非ES搜索命令的全部，ES有着强大的搜索功能，这也意味着ES的查询语句将比较复杂，建议在掌握了本节所列举的这些基础语法后，再上网搜索其他更复杂更强大的命令。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/MyBlog/tags/Hadoop/" rel="tag"># Hadoop</a>
              <a href="/MyBlog/tags/ElasticSearch/" rel="tag"># ElasticSearch</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/MyBlog/2019/12/25/hbase-shell-filter/" rel="prev" title="HBase Shell 过滤器 —— HBase Shell Filter">
      <i class="fa fa-chevron-left"></i> HBase Shell 过滤器 —— HBase Shell Filter
    </a></div>
      <div class="post-nav-item">
    <a href="/MyBlog/2020/01/06/hadoop-hive/" rel="next" title="Hadoop快速入门系列——篇三：Hive">
      Hadoop快速入门系列——篇三：Hive <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">winyter</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/MyBlog/lib/anime.min.js"></script>

<script src="/MyBlog/js/utils.js"></script>

<script src="/MyBlog/js/motion.js"></script>


<script src="/MyBlog/js/next-boot.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  















  

  

</body>
</html>
